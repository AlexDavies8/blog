
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Illusion of Research</title>
    <meta name="description" content="">

    <link rel="stylesheet" href="/blog/index.css">
    <link rel="alternate" href="." type="application/atom+xml" title="">
    <link rel="alternate" href="." type="application/json" title="">
  <style id="MJX-SVG-styles">
mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax="SVG"] > svg a {
  fill: blue;
  stroke: blue;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line], svg[data-table] > g > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame], svg[data-table] > g > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed, svg[data-table] > g > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted, svg[data-table] > g > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > g > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax="SVG"] path[data-c], mjx-container[jax="SVG"] use[data-c] {
  stroke-width: 3;
}
</style></head>
  <body>
    <main class="tmpl-post">
      <div class="profile">
    <div class="profile-section">
        <a href="/blog/">
            <picture><source type="image/webp" srcset="/blog/img/-gO1BfWkaA-2048.webp 2048w"><img class="avatar-img" alt="Logo" src="/blog/img/-gO1BfWkaA-2048.jpeg" width="2048" height="2048"></picture>
        
            <h1 class="avatar-name">Alex's Blog</h1>
            <p class="avatar-sub">code and stuff</p>
        </a>
    </div>
</div>

      <div class="wrapper">
        <article class="article">
  <header class="article-header">
    <h1>The Illusion of Research</h1>
    <div class="article-header-meta">
      <time class="posts-list-date">16 Jun 2025</time>
    </div>
  </header>

  <p>Apple researchers recently released a rather bold paper called <a href="https://ml-site.cdn-apple.com/papers/the-illusion-of-thinking.pdf">The Illusion of Thinking</a>, which was picked up by both media outlets and social media alike as some kind of proof that AI is a fad, or that they are incapable of reasoning, or one of many other claims.</p>
<iframe style="width:100%;aspect-ratio:16/9" src="https://www.youtube.com/embed/u31qwQUeGuM?si=2x97uFDoJqOfAdu4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>However, this isn't just a case of people reading the title and making up some fantastical story - the paper really does make some absurd and quite frankly unfounded claims, although they aren't quite the claims reported in most online coverage.</p>
<h1>'Generalisable' Problem Solving</h1>
<blockquote>
<p>We show that state-of-the-art LRMs (e.g., o3-mini, DeepSeek-R1, Claude-3.7-Sonnet-Thinking) still fail to develop generalizable problem-solving capabilities.</p>
</blockquote>
<p>This is a quote directly from the paper, but what does this actually mean? Well, the authors never seemed to feel the need to clarify this, but there are many thinks that this could refer to, even within the context of machine learning.</p>
<p>The paper evaluates 'generalisable reasoning capabilities' by testing them on a handful of common logic puzzles, many of which often used in machine learning. But the kind of reasoning that these problems demonstrate is quite specific - something referred to as 'Planning', although this is a bit less general than it sounds.</p>
<p>For many problems we can represent them as having a 'state space' - a point in this space represents a single state the game can be in. Then, we can create arrows, often called 'edges', between these points, representing an action that takes us from one state to another. Lets see this in action by looking at one of the puzzles used in the paper - Tower of Hanoi.</p>
<p>Tower of Hanoi involves three poles that can have discs on them. The discs start on the first poles, with the largest at the bottom, decreasing in size as they go up. The aim is to move the discs onto the last pole in the same configuration - largest at the bottom, smallest at the top - in the fewest number of moves. There are only three rules - you can only move one disc at a time, you can only move the top disc on any given pole, and you cannot place a disc on top of a smaller one. You can try it out below - see if you can figure out any patterns for how to solve it.</p>
<div class="towers-of-hanoi-container">
    <div class="container">
        <div class="controls">
            <div class="slider-container">
                <label for="ringCount">Rings:</label>
                <input type="range" id="ringCount" min="1" max="8" value="3">
                <span id="ringCountDisplay">3</span>
            </div>
            <div class="stats">
                <div>Moves: <span id="moveCount">0</span></div>
                <div>Optimal: <span id="optimalMoves">7</span></div>
            </div>
            <button id="resetBtn">Reset Game</button>
        </div>
        <div id="victoryMessage" class="victory" style="display: none;">
            ðŸŽ‰ Congratulations! You solved it! ðŸŽ‰
        </div>
        <div class="game-area">
            <div class="tower" data-tower="0"></div>
            <div class="tower" data-tower="1"></div>
            <div class="tower" data-tower="2"></div>
        </div>
    </div>
</div>
<style>
    .towers-of-hanoi-container {
        /* margin: 2rem 0; */
        display: flex;
        justify-content: center;
        position: relative;
        width: 710px;
        max-width: 710px;
    }
    
    .towers-of-hanoi-container .container {
        background: white;
        border-radius: 15px;
        padding: 30px;
        /* box-shadow: 0 10px 30px rgba(0,0,0,0.3); */
        max-width: 800px;
        width: 100%;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
    }

    .towers-of-hanoi-container h1 {
        text-align: center;
        color: white;
        margin-bottom: 30px;
    }

    .towers-of-hanoi-container .controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 30px;
        flex-wrap: wrap;
        gap: 15px;
    }

    .towers-of-hanoi-container .control-group {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .towers-of-hanoi-container .slider-container {
        display: flex;
        align-items: center;
        gap: 10px;
        background: rgba(255,255,255,0.2);
        color: white;
        border: 2px solid rgba(255,255,255,0.3);
        padding: 10px 20px;
        border-radius: 5px;
        font-size: 14px;
    }

    .towers-of-hanoi-container input[type="range"] {
        width: 100px;
    }

    .towers-of-hanoi-container button {
        background: rgba(255,255,255,0.2);
        color: white;
        border: 2px solid rgba(255,255,255,0.3);
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
    }

    .towers-of-hanoi-container button:hover {
        background: rgba(255,255,255,0.3);
        border-color: rgba(255,255,255,0.5);
    }

    .towers-of-hanoi-container .stats {
        display: flex;
        justify-content: center;
        gap: 30px;
        font-weight: bold;
    }

    .towers-of-hanoi-container .game-area {
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        height: 300px;
        margin: 20px 0;
        position: relative;
    }

    .towers-of-hanoi-container .tower {
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        width: 200px;
        height: 100%;
        position: relative;
        padding-bottom: 15px;
    }

    .towers-of-hanoi-container .tower::before {
        content: '';
        position: absolute;
        bottom: 0;
        width: 10px;
        height: 250px;
        background: #8B4513;
        border-radius: 5px;
    }

    .towers-of-hanoi-container .tower::after {
        content: '';
        position: absolute;
        bottom: 0;
        width: 180px;
        height: 15px;
        background: #654321;
        border-radius: 7px;
        z-index: 1;
    }

    .towers-of-hanoi-container .ring {
        height: 25px;
        border-radius: 12px;
        margin: 2px 0;
        cursor: grab;
        position: relative;
        z-index: 10;
        border: 2px solid rgba(0,0,0,0.2);
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .towers-of-hanoi-container .ring:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }

    .towers-of-hanoi-container .ring.dragging {
        cursor: grabbing;
        transform: scale(1.05);
        z-index: 1000;
        box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    }

    .towers-of-hanoi-container .victory {
        position: absolute;
        /* top: 50%; */
        left: 50%;
        text-align: center;
        color: white;
        font-size: 24px;
        font-weight: bold;
        white-space: nowrap;
        overflow: hidden;
        animation: bounce 1s infinite;
    }

    @keyframes bounce {
        0%, 20%, 50%, 80%, 100% { transform: translate(-50%, -50%) translateY(0); }
        40% { transform: translate(-50%, -50%) translateY(-10px); }
        60% { transform: translate(-50%, -50%) translateY(-5px); }
    }
</style>
<script>
    (function() {
        // Wrap in IIFE to avoid global conflicts
        class TowersOfHanoi {
            constructor() {
                this.rings = 3;
                this.moves = 0;
                this.towers = [[], [], []];
                this.draggedRing = null;
                this.draggedFrom = null;
                
                this.initializeElements();
                this.setupEventListeners();
                this.resetGame();
            }

            initializeElements() {
                const container = document.querySelector('.towers-of-hanoi-container');
                this.ringCountSlider = container.querySelector('#ringCount');
                this.ringCountDisplay = container.querySelector('#ringCountDisplay');
                this.resetBtn = container.querySelector('#resetBtn');
                this.moveCountDisplay = container.querySelector('#moveCount');
                this.optimalMovesDisplay = container.querySelector('#optimalMoves');
                this.victoryMessage = container.querySelector('#victoryMessage');
                this.towerElements = container.querySelectorAll('.tower');
            }

            setupEventListeners() {
                this.ringCountSlider.addEventListener('input', (e) => {
                    this.rings = parseInt(e.target.value);
                    this.ringCountDisplay.textContent = this.rings;
                    this.resetGame();
                });

                this.resetBtn.addEventListener('click', () => this.resetGame());

                document.addEventListener('mousedown', (e) => this.handleStart(e));
                document.addEventListener('mousemove', (e) => this.handleMove(e));
                document.addEventListener('mouseup', (e) => this.handleEnd(e));
                
                document.addEventListener('touchstart', (e) => this.handleStart(e));
                document.addEventListener('touchmove', (e) => this.handleMove(e));
                document.addEventListener('touchend', (e) => this.handleEnd(e));
            }

            resetGame() {
                this.moves = 0;
                this.towers = [[], [], []];
                this.victoryMessage.style.display = 'none';
                
                for (let i = this.rings; i >= 1; i--) {
                    this.towers[0].push(i);
                }
                
                this.updateDisplay();
                this.updateOptimalMoves();
            }

            updateOptimalMoves() {
                const optimal = Math.pow(2, this.rings) - 1;
                this.optimalMovesDisplay.textContent = optimal;
            }

            updateDisplay() {
                this.moveCountDisplay.textContent = this.moves;
                
                this.towerElements.forEach(tower => {
                    const rings = tower.querySelectorAll('.ring');
                    rings.forEach(ring => ring.remove());
                });

                this.towers.forEach((tower, towerIndex) => {
                    const towerElement = this.towerElements[towerIndex];
                    tower.forEach(ringSize => {
                        const ring = this.createRingElement(ringSize);
                        towerElement.appendChild(ring);
                    });
                });

                this.checkVictory();
            }

            createRingElement(size) {
                const ring = document.createElement('div');
                ring.className = 'ring';
                ring.dataset.size = size;
                
                const width = 60 + (size * 20);
                const hue = (size * 40) % 360;
                
                ring.style.width = width + 'px';
                ring.style.backgroundColor = `hsl(${hue}, 70%, 60%)`;
                
                return ring;
            }

            handleStart(e) {
                const target = e.target.closest('.ring');
                if (!target || !target.closest('.towers-of-hanoi-container')) return;

                e.preventDefault();
                const tower = target.parentElement;
                const towerIndex = parseInt(tower.dataset.tower);
                const rings = Array.from(tower.querySelectorAll('.ring'));
                const topRing = rings[rings.length - 1];

                if (target !== topRing) return;

                this.draggedRing = target;
                this.draggedFrom = towerIndex;
                target.classList.add('dragging');
                
                const rect = target.getBoundingClientRect();
                this.dragOffset = {
                    x: (e.clientX || e.touches[0].clientX) - rect.left,
                    y: (e.clientY || e.touches[0].clientY) - rect.top
                };
            }

            handleMove(e) {
                if (!this.draggedRing) return;
                e.preventDefault();

                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;

                this.draggedRing.style.position = 'fixed';
                this.draggedRing.style.left = (clientX - this.dragOffset.x) + 'px';
                this.draggedRing.style.top = (clientY - this.dragOffset.y) + 'px';
                this.draggedRing.style.pointerEvents = 'none';

                this.towerElements.forEach(tower => {
                    tower.classList.remove('highlight');
                    const rect = tower.getBoundingClientRect();
                    if (clientX >= rect.left && clientX <= rect.right &&
                        clientY >= rect.top && clientY <= rect.bottom) {
                        const towerIndex = parseInt(tower.dataset.tower);
                        if (this.canPlaceRing(towerIndex, parseInt(this.draggedRing.dataset.size))) {
                            tower.classList.add('highlight');
                        }
                    }
                });
            }

            handleEnd(e) {
                if (!this.draggedRing) return;

                const clientX = e.clientX || e.changedTouches[0].clientX;
                const clientY = e.clientY || e.changedTouches[0].clientY;

                let targetTower = null;
                this.towerElements.forEach(tower => {
                    const rect = tower.getBoundingClientRect();
                    if (clientX >= rect.left && clientX <= rect.right &&
                        clientY >= rect.top && clientY <= rect.bottom) {
                        targetTower = parseInt(tower.dataset.tower);
                    }
                    tower.classList.remove('highlight');
                });

                this.draggedRing.classList.remove('dragging');
                this.draggedRing.style.position = '';
                this.draggedRing.style.left = '';
                this.draggedRing.style.top = '';
                this.draggedRing.style.pointerEvents = '';

                if (targetTower !== null && targetTower !== this.draggedFrom) {
                    const ringSize = parseInt(this.draggedRing.dataset.size);
                    if (this.canPlaceRing(targetTower, ringSize)) {
                        this.moveRing(this.draggedFrom, targetTower);
                    }
                }

                this.draggedRing = null;
                this.draggedFrom = null;
                this.updateDisplay();
            }

            canPlaceRing(towerIndex, ringSize) {
                const tower = this.towers[towerIndex];
                return tower.length === 0 || tower[tower.length - 1] > ringSize;
            }

            moveRing(fromTower, toTower) {
                const ring = this.towers[fromTower].pop();
                this.towers[toTower].push(ring);
                this.moves++;
            }

            checkVictory() {
                if (this.towers[2].length === this.rings) {
                    this.victoryMessage.style.display = 'block';
                }
            }
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => new TowersOfHanoi());
        } else {
            new TowersOfHanoi();
        }
    })();
</script>
<p>The state space for Tower of Hanoi gets quite large, so let's just look at a section of it for 3 disc. For this puzzle, since every move can be reversed by just moving the disc back, all edges are bi-directional (can be taken in either direction).</p>
<picture><source type="image/webp" srcset="/blog/posts/illusion-of-research/tZONZ_Jezl-1680.webp 1680w"><img src="/blog/posts/illusion-of-research/tZONZ_Jezl-1680.jpeg" alt="Subsection of the state space for Tower of Hanoi" width="1680" height="763"></picture>
<p>Planning, as a form of reasoning, involves finding a path from a specific start state to a specific end state. Some puzzles are happy to accept any path - as long as you get there eventually, it's considered solved. Other puzzles may require the shortest path; the least number of moves.</p>
<p>You might have noticed that when solving Tower of Hanoi, you end up in a consistent pattern, especially as you increase the number of discs (denoted <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container>). As it turns out, there is a well known algorithm for solving Tower of Hanoi, which can be seen below. It's not a problem if you don't understand it, what's important is just that it exists and is fairly easy to carry out step by step.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">towers_of_hanoi</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> source<span class="token punctuation">,</span> auxiliary<span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Move disc 1 from </span><span class="token interpolation"><span class="token punctuation">{</span>source<span class="token punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token punctuation">{</span>destination<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        towers_of_hanoi<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> auxiliary<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f"Move disc </span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">}</span></span><span class="token string"> from </span><span class="token interpolation"><span class="token punctuation">{</span>source<span class="token punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token punctuation">{</span>destination<span class="token punctuation">}</span></span><span class="token string">"</span></span><span class="token punctuation">)</span>
        towers_of_hanoi<span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> auxiliary<span class="token punctuation">,</span> source<span class="token punctuation">,</span> destination<span class="token punctuation">)</span></code></pre>
<p>To solve the puzzle for 3 rings, you would perform <code>towers_of_hanoi(3, 'A', 'B', 'C')</code>, where the 3 poles are labelled A, B and C respectively.</p>
<details>
<summary>See this algorithm run step by step</summary>
<pre class="language-python"><code class="language-python">towers_of_hanoi<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span>
    towers_of_hanoi<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span>
        towers_of_hanoi<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span>
            <span class="token comment"># Move disc 1 from A to C</span>
        <span class="token comment"># Move disc 2 from A to B</span>
        towers_of_hanoi<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">)</span>
            <span class="token comment"># Move disc 1 from C to B</span>
    <span class="token comment"># Move disc 3 from A to C</span>
    towers_of_hanoi<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span>
        towers_of_hanoi<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span>
            <span class="token comment"># Move disc 1 from B to A</span>
        <span class="token comment"># Move disc 2 from B to C</span>
        towers_of_hanoi<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span>
            <span class="token comment"># Move disc 1 from A to C</span></code></pre>
</details>
<p>If we think about this algorithm in terms of the 'state space' of the problem, the algorithm gives us a guaranteed way to find the shortest path to the solved state.</p>
<picture><source type="image/webp" srcset="/blog/posts/illusion-of-research/PmKT57by1i-1680.webp 1680w"><img src="/blog/posts/illusion-of-research/PmKT57by1i-1680.jpeg" alt="Path through the state space" width="1680" height="763"></picture>
<p>So how is this important? Well, if we use the algorithm, we don't really have to do any planning. The algorithm may take a bit of work to run, but we don't have to think multiple moves ahead; we don't need to consider the implications that our next move may have on future moves. That's not to say that running the algorithm doesn't show <em>something</em> - at the very least it can demonstrate that you can reliably follow a set list of instructions. But would we really say this is a good model for 'generalisable reasoning capabilities'?</p>
<h1>Asking for the Impossible</h1>
<p>As it turns out, quite a lot of what the authors were asking the LLMs to solve is either impossible, or completely impractical, given the constraints they impose. To figure out why, we need to analyse how hard it is to solve each problem in a more objective sense.</p>
<h2>What Constraints?</h2>
<p>The main constraint on the LLMs within the paper that is consistent across all problems is a token limit. This simply caps the number of tokens that it's allowed to output to a fixed number - in this case to 64,000. This includes both the tokens used for thinking, and the tokens required for the final answer.</p>
<h2>Towers of Hanoi</h2>
<p>The algorithm to solve Tower of Hanoi requires <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.176ex" height="1.714ex" role="img" focusable="false" viewBox="0 -675.5 2729.7 757.5" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(1229.5,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(2229.7,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mi>n</mi></msup><mo>âˆ’</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container> steps, where <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> is the number of discs. The paper requires that each move is outputted in the format <code>[disc_id, source, target]</code>. For example, to move the second smallest disc from the first ring to the last ring, we perform the move <code>[1, 0, 2]</code> (we generally start counting at 0 when programming). discs are labelled with the smallest as 0 and the largest as <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.254ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2322.4 748" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(822.2,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1822.4,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>âˆ’</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container>. Now, we need to figure out how many tokens each move will require to write out. Luckily, OpenAI provides their tokeniser publicly, and using it we can see that a single move takes 6 tokens (including spaces it actually requires 9, but I'll underestimate to be generous), although this may increase as we get to <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.637ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2933.6 748" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(877.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1933.6,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use><use data-c="31" xlink:href="#MJX-TEX-N-31" transform="translate(500,0)"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>11</mn></math></mjx-assistive-mml></mjx-container> and the number of digits increases. Therefore, at absolute minimum, we have the following equation for the number of tokens required <strong>just to write out the final answer</strong> - this isn't including any working out or reasoning.
<mjx-container class="MathJax" jax="SVG" display="true" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="21.21ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9374.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><use data-c="74" xlink:href="#MJX-TEX-N-74"></use><use data-c="6F" xlink:href="#MJX-TEX-N-6F" transform="translate(389,0)"></use><use data-c="6B" xlink:href="#MJX-TEX-N-6B" transform="translate(889,0)"></use><use data-c="65" xlink:href="#MJX-TEX-N-65" transform="translate(1417,0)"></use><use data-c="6E" xlink:href="#MJX-TEX-N-6E" transform="translate(1861,0)"></use><use data-c="73" xlink:href="#MJX-TEX-N-73" transform="translate(2417,0)"></use></g><g data-mml-node="mo" transform="translate(3088.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(4144.6,0)"><use data-c="36" xlink:href="#MJX-TEX-N-36"></use></g><g data-mml-node="mo" transform="translate(4866.8,0)"><use data-c="D7" xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mo" transform="translate(5867,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(6256,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(7485.5,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(8485.7,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(8985.7,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>tokens</mtext><mo>=</mo><mn>6</mn><mo>Ã—</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>
From the paper's results, we can also find the average number of tokens <em>actually</em> used per step of the algorithm. I've done this for o3-mini, based on Figure 13 in the paper by fitting the line <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="21.058ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9307.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><use data-c="74" xlink:href="#MJX-TEX-N-74"></use><use data-c="6F" xlink:href="#MJX-TEX-N-6F" transform="translate(389,0)"></use><use data-c="6B" xlink:href="#MJX-TEX-N-6B" transform="translate(889,0)"></use><use data-c="65" xlink:href="#MJX-TEX-N-65" transform="translate(1417,0)"></use><use data-c="6E" xlink:href="#MJX-TEX-N-6E" transform="translate(1861,0)"></use><use data-c="73" xlink:href="#MJX-TEX-N-73" transform="translate(2417,0)"></use></g><g data-mml-node="mo" transform="translate(3088.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mi" transform="translate(4144.6,0)"><use data-c="1D450" xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mo" transform="translate(4799.8,0)"><use data-c="D7" xlink:href="#MJX-TEX-N-D7"></use></g><g data-mml-node="mo" transform="translate(5800,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(6189,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(7418.5,0)"><use data-c="2212" xlink:href="#MJX-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(8418.7,0)"><use data-c="31" xlink:href="#MJX-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(8918.7,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>tokens</mtext><mo>=</mo><mi>c</mi><mo>Ã—</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> to the graph<mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="0.988ex" height="1.565ex" role="img" focusable="false" viewBox="0 -691.8 436.6 691.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"></g><g data-mml-node="mo" transform="translate(33,363) scale(0.707)"><use data-c="2217" xlink:href="#MJX-TEX-N-2217"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi></mi><mo>âˆ—</mo></msup></math></mjx-assistive-mml></mjx-container>, where <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.98ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 433 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D450" xlink:href="#MJX-TEX-I-1D450"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math></mjx-assistive-mml></mjx-container> is the number of tokens required per step. This gives a value for <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.98ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 433 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D450" xlink:href="#MJX-TEX-I-1D450"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math></mjx-assistive-mml></mjx-container> of about 185 tokens of thinking per step of the algorithm.
Now, we can draw out a graph of the number of tokens required.</p>
<picture><source type="image/webp" srcset="/blog/posts/illusion-of-research/0ifajejhqc-5260.webp 5260w"><img src="/blog/posts/illusion-of-research/0ifajejhqc-5260.jpeg" alt="Graph showing required and estimated token counts" width="5260" height="3177"></picture>
<p>So we can see quite clearly that any number of discs over 13 is completely impossible - even if the LLM could magically produce the answer from thin air, it wouldn't be able to write it out. But even more interesting is that with the amount of working out the LLM is doing per step, unless it can somehow magically become far more efficient with its working out, it couldn't complete even 9 discs within the token limit. Given that o3-mini successfully completes the problem for 7 discs roughly half of the time - with Claude (thinking) and Deepseek R1 even sometimes completing 8 discs - these models are doing just about the best they can on this problem.</p>
<h2>River Crossing</h2>
<p>Another puzzle used in the paper is the River Crossing problem, involving <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> actors and <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> agents, as well as a boat that can contain a maximum of <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></mjx-assistive-mml></mjx-container> people at a given time. Everyone starts on the left bank of a river, including the boat. The aim is to transport everyone to the other side. The boat requires at least 1 person inside to be able to move, and an actor cannot be left with another agent unless it's own agent is also with it.</p>
<p>Not all combinations of <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> and <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></mjx-assistive-mml></mjx-container> allow for a valid solution. For example, when <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> is 6 or more and <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></mjx-assistive-mml></mjx-container> is 3, it's not possible to solve the problem - no matter what you try, you'll end up being unable to move everyone to the other side without violating the rules above. In fact, this is subtly hinted at in the paper itself:</p>
<blockquote>
<p>Boat Capacity Constraint: The boat can carry at most <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></mjx-assistive-mml></mjx-container> individuals at a time, where <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewBox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi></math></mjx-assistive-mml></mjx-container> is typically set to 2 for smaller puzzles <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.918ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3499.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(389,0)"><use data-c="1D441" xlink:href="#MJX-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(1554.8,0)"><use data-c="2264" xlink:href="#MJX-TEX-N-2264"></use></g><g data-mml-node="mn" transform="translate(2610.6,0)"><use data-c="33" xlink:href="#MJX-TEX-N-33"></use></g><g data-mml-node="mo" transform="translate(3110.6,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>N</mi><mo>â‰¤</mo><mn>3</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> and 3 for larger puzzles <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.918ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3499.6 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(389,0)"><use data-c="1D441" xlink:href="#MJX-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(1554.8,0)"><use data-c="2264" xlink:href="#MJX-TEX-N-2264"></use></g><g data-mml-node="mn" transform="translate(2610.6,0)"><use data-c="35" xlink:href="#MJX-TEX-N-35"></use></g><g data-mml-node="mo" transform="translate(3110.6,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi>N</mi><mo>â‰¤</mo><mn>5</mn><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>.</p>
</blockquote>
<p>But then they specifically state that they use <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.327ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2354.6 776" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(798.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1854.6,0)"><use data-c="33" xlink:href="#MJX-TEX-N-33"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>3</mn></math></mjx-assistive-mml></mjx-container> for all <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> above 3.</p>
<blockquote>
<p>For <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="12.018ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 5311.8 860" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(877.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1933.6,0)"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g><g data-mml-node="mo" transform="translate(2433.6,0)"><use data-c="2C" xlink:href="#MJX-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(2878.2,0)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(3756,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(4811.8,0)"><use data-c="33" xlink:href="#MJX-TEX-N-33"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>2</mn><mo>,</mo><mi>n</mi><mo>=</mo><mn>3</mn></math></mjx-assistive-mml></mjx-container> pairs, we use boat capacity of <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.327ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2354.6 776" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(798.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1854.6,0)"><use data-c="32" xlink:href="#MJX-TEX-N-32"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>2</mn></math></mjx-assistive-mml></mjx-container> and for larger number of pairs we use <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.327ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2354.6 776" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-TEX-I-1D458"></use></g><g data-mml-node="mo" transform="translate(798.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1854.6,0)"><use data-c="33" xlink:href="#MJX-TEX-N-33"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>k</mi><mo>=</mo><mn>3</mn></math></mjx-assistive-mml></mjx-container>.</p>
</blockquote>
<p>So then it's hardly a surprise that the results for the River Crossing task show failure for all LLMs at <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.506ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2433.6 748" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(877.8,0)"><use data-c="3D" xlink:href="#MJX-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1933.6,0)"><use data-c="36" xlink:href="#MJX-TEX-N-36"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>=</mo><mn>6</mn></math></mjx-assistive-mml></mjx-container> - they're asking them to find a solution that doesn't exist.</p>
<picture><source type="image/webp" srcset="/blog/posts/illusion-of-research/zxXyta8KFQ-705.webp 705w"><img src="/blog/posts/illusion-of-research/zxXyta8KFQ-705.jpeg" alt="Graph showing river crossing accuracy vs number of people" width="705" height="605"></picture>
<h2>Blocks World</h2>
<h1>TODO: REWRITE SECTION - SEE DISCLAIMERS BELOW</h1>
<blockquote>
<p>Pretty sure the authors fucked up literally the entire evaluation for this section, because their numbers for number of moves for the solutions to this problem are just wrong - they are clearly using some non-optimal strategy. I'm pretty sure that every single model on the market actually scores 0 on this problem past trivial cases like N=3 and below.</p>
</blockquote>
<blockquote>
<p>Optimal strategy is move all apart from 1 block from stack 0 to stack 1 (1 block at a time), then move last from stack 0 to stack 2. Move all the stuff that used to be in stack 0 from the top of stack 1 to stack 2. Now you can alternate which stack you take from and put into stack 0, starting with 1 (i.e. move top of stack 1 to stack 0, then top of stack 2 to 0, then 1 to 0, then 2 to 0, ...). You should now have target solution.</p>
</blockquote>
<p>Blocks World is a puzzle that involves moving blocks around to try and reach a given target state from an initial state in the fewest moves. It's similar to Tower of Hanoi, but is much more general - the only restriction is that a block can only be picked up or placed on the top of a stack (or on an empty stack). For the general case, the best we can really do to solve this algorithmically is to search through all the possible block arrangements using something like A* - a common search algorithm used for planning problems. But even using this, it can easily require checking hundreds of thousands of arrangements for anything more than 10 blocks.</p>
<p>But the LLMs manage to do much better than this - o3-mini was able to solve it for 40 blocks! How?</p>
<p>Well, the paper doesn't randomly generate initial and target states, or really do anything to create a typical 'general' case. Instead, for <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> blocks, they start with two stacks, each with half the blocks in. For the target, they just require that the 2 stacks have been interleaved, with the final stack being the left-most stack. Try below to see if you can figure out any patterns.</p>
<div id="game-container">
    <div class="controls">
        <div class="control-group">
            <label for="blockCount">Blocks:</label>
            <input type="range" id="blockCount" min="2" max="10" value="4" step="1">
            <span id="blockCountDisplay">4</span>
        </div>
        <div class="control-group">
            <label for="moveCount">Moves:</label>
            <span id="moveCountDisplay">0</span>
        </div>
        <div class="control-group">
            <label for="optimalCount">Optimal:</label>
            <span id="optimalCountDisplay">0</span>
        </div>
        <button class="view-target-btn" onmouseenter="showTarget()" onmouseleave="hideTarget()">View Target</button>
        <button class="reset-btn" onclick="resetGame()">Reset Game</button>
    </div>
    <div class="game-board" id="gameBoard">
        <div class="tower-container">
            <div class="stack" data-stack="0" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
            <div class="stack-base"></div>
        </div>
        <div class="tower-container">
            <div class="stack" data-stack="1" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
            <div class="stack-base"></div>
        </div>
        <div class="tower-container">
            <div class="stack" data-stack="2" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
            <div class="stack-base"></div>
        </div>
    </div>
    <div class="target-overlay hidden" id="targetOverlay">
        <div class="target-board">
            <div class="tower-container">
                <div class="stack"></div>
                <div class="stack-base"></div>
            </div>
            <div class="tower-container">
                <div class="stack"></div>
                <div class="stack-base"></div>
            </div>
            <div class="tower-container">
                <div class="stack"></div>
                <div class="stack-base"></div>
            </div>
        </div>
    </div>
    <div class="win-message hidden" id="winMessage">
        <div class="win-content">
            <h2>ðŸŽ‰ Congratulations! ðŸŽ‰</h2>
            <p>You solved the puzzle!</p>
            <button onclick="nextPuzzle()">Next Puzzle</button>
        </div>
    </div>
</div>
<style>
    #game-container {
        width: 710px;
        margin: 0 auto;
        padding: 20px;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        position: relative;
    }

    #game-container .controls {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        align-items: center;
        justify-content: space-between;
        background: rgba(255,255,255,0.15);
        padding: 15px 20px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
    }

    #game-container .control-group {
        display: flex;
        align-items: center;
        gap: 8px;
        color: white;
        font-weight: 600;
    }

    #game-container .controls label,
    #game-container .controls span {
        color: white;
        font-weight: 600;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    #game-container .controls input[type="range"] {
        width: 100px;
        height: 6px;
        background: rgba(255,255,255,0.3);
        border-radius: 3px;
        outline: none;
    }

    #game-container .controls input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        width: 18px;
        height: 18px;
        background: #4CAF50;
        border-radius: 50%;
        cursor: pointer;
    }

    #game-container .controls button {
        padding: 10px 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    #game-container .view-target-btn {
        background: rgba(255,255,255,0.9);
        color: #333;
    }

    #game-container .view-target-btn:hover {
        background: white;
        transform: translateY(-2px);
    }

    #game-container .reset-btn {
        background: #ff6b6b;
        color: white;
    }

    #game-container .reset-btn:hover {
        background: #ff5252;
        transform: translateY(-2px);
    }

    #game-container .game-board {
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        min-height: 350px;
        background: rgba(255,255,255,0.1);
        border-radius: 15px;
        padding: 30px 20px 20px;
        position: relative;
        backdrop-filter: blur(5px);
    }

    #game-container .target-overlay {
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        min-height: 350px;
        background: rgba(255,255,255,0.1);
        border-radius: 15px;
        padding: 30px 20px 20px;
        position: relative;
        backdrop-filter: blur(5px);
        z-index: 100;
    }

    #game-container .target-board {
        display: flex;
        justify-content: space-around;
        align-items: flex-end;
        width: 100%;
        height: 100%;
    }

    #game-container .tower-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        height: 500px;
        justify-content: flex-end;
    }

    #game-container .stack-base {
        width: 120px;
        height: 10px;
        background: linear-gradient(to bottom, #8B4513, #654321);
        border-radius: 50px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        position: relative;
        z-index: 0;
    }

    #game-container .stack {
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        position: absolute;
        bottom: 10px;
        width: 120px;
        height: 100%;
        z-index: 2;
        justify-content: flex-start;
    }

    #game-container .block {
        width: 50px;
        height: 50px;
        min-width: 50px;
        min-height: 50px;
        margin: 1px 0;
        border-radius: 6px;
        border: 2px solid rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        font-weight: bold;
        user-select: none;
        background: linear-gradient(145deg, rgba(255,255,255,0.4), rgba(0,0,0,0.1));
        box-shadow: 0 3px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.5);
        transition: all 0.2s ease;
        color: white;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        cursor: default;
    }

    #game-container .block.draggable {
        cursor: grab;
    }

    #game-container .block.draggable:hover {
        transform: scale(1.05) translateY(-2px);
        box-shadow: 0 5px 10px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,0.6);
    }

    #game-container .block.draggable:active {
        cursor: grabbing;
    }

    #game-container .block.dragging {
        opacity: 0.8;
        transform: rotate(5deg) scale(1.1);
        z-index: 1000;
        box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    }

    #game-container .block-a { background: linear-gradient(145deg, #4CAF50, #45a049); }
    #game-container .block-b { background: linear-gradient(145deg, #f44336, #da190b); }
    #game-container .block-c { background: linear-gradient(145deg, #2196F3, #0b7dda); }
    #game-container .block-d { background: linear-gradient(145deg, #FF9800, #e68900); }
    #game-container .block-e { background: linear-gradient(145deg, #9C27B0, #7b1fa2); }
    #game-container .block-f { background: linear-gradient(145deg, #607D8B, #455a64); }

    #game-container .hidden {
        display: none !important;
    }

    #game-container .target-overlay::before {
        content: "TARGET ARRANGEMENT";
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        font-weight: bold;
        font-size: 18px;
        color: #333;
        background: rgba(255,255,255,0.9);
        padding: 8px 16px;
        border-radius: 20px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }

    #game-container .win-message {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border-radius: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 200;
    }

    #game-container .win-content {
        background: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    #game-container .win-content h2 {
        margin: 0 0 15px 0;
        color: #4CAF50;
    }

    #game-container .win-content button {
        padding: 10px 20px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        margin-top: 15px;
    }
</style>
<script>
    let currentState = [[], [], []];
    let targetState = [[], [], []];
    const blockColors = ['a', 'b', 'c', 'd', 'e', 'f'];
    let moveCount = 0;
    
    function getCharFromNumber(num) {
        if (num >= 0 && num <= 25) return String.fromCharCode(65 + num);
        else if (num >= 26 && num <= 51) return String.fromCharCode(97 + (num - 26));
        else if (num >= 52 && num <= 61) return String.fromCharCode(48 + (num - 52));
        return "?";
    }

    function setupGame() {
        const blockCount = parseInt(document.getElementById('blockCount').value);
        document.getElementById('blockCountDisplay').textContent = blockCount;

        moveCount = 0;
        document.getElementById('moveCountDisplay').textContent = moveCount;
        const optimal = (blockCount % 2 === 0) ? 2 * blockCount - 1 : 2 * blockCount - 2;
        document.getElementById('optimalCountDisplay').textContent = optimal;
        
        // Reset states
        currentState = [[], [], []];
        targetState = [[], [], []];
        
        // Create initial state
        const halfCount = Math.floor(blockCount / 2);
        for (let i = 0; i < halfCount; i++) currentState[0].push(i);
        for (let i = halfCount; i < blockCount; i++) currentState[1].push(i);

        // Create target state (interleaved)
        const stack1 = [...currentState[0]].reverse();
        const stack2 = [...currentState[1]].reverse();
        while (stack1.length > 0 || stack2.length > 0) {
            if (stack2.length > 0) targetState[0].push(stack2.shift());
            if (stack1.length > 0) targetState[0].push(stack1.shift());
        }

        renderGame();
        hideWinMessage();
    }

    function renderGame() {
        renderState(currentState, '#gameBoard .stack');
    }

    function renderTarget() {
        renderState(targetState, '#targetOverlay .stack');
    }

    function renderState(state, selector) {
        const stacks = document.querySelectorAll(selector);
        stacks.forEach((stack, stackIndex) => {
            stack.innerHTML = '';
            state[stackIndex].forEach((blockIndex, position) => {
                const block = createBlock(blockIndex);
                const isTopBlock = position === state[stackIndex].length - 1;
                if (isTopBlock && selector.includes('gameBoard')) {
                    block.classList.add('draggable');
                    block.draggable = true;
                }
                stack.appendChild(block);
            });
        });
    }

    function createBlock(blockIndex) {
        const block = document.createElement('div');
        block.className = `block block-${blockColors[blockIndex % blockColors.length]}`;
        block.textContent = getCharFromNumber(blockIndex);
        block.dataset.blockIndex = blockIndex;
        block.ondragstart = drag;
        return block;
    }

    function checkWin() {
        const isWin = currentState.every((stack, i) => 
            stack.length === targetState[i].length && 
            stack.every((block, j) => block === targetState[i][j])
        );
        if (isWin) showWinMessage();
    }

    function showWinMessage() {
        document.getElementById('winMessage').classList.remove('hidden');
    }

    function hideWinMessage() {
        document.getElementById('winMessage').classList.add('hidden');
    }

    function nextPuzzle() {
        const slider = document.getElementById('blockCount');
        if (slider.value < slider.max) {
            slider.value = parseInt(slider.value) + 1;
        } else {
            slider.value = slider.min;
        }
        setupGame();
    }

    function resetGame() {
        setupGame();
    }

    function showTarget() {
        renderTarget();
        document.getElementById('gameBoard').classList.add('hidden');
        document.getElementById('targetOverlay').classList.remove('hidden');
    }

    function hideTarget() {
        document.getElementById('gameBoard').classList.remove('hidden');
        document.getElementById('targetOverlay').classList.add('hidden');
    }

    function allowDrop(ev) {
        ev.preventDefault();
    }

    function drag(ev) {
        if (!ev.target.classList.contains('draggable')) {
            ev.preventDefault();
            return;
        }
        ev.dataTransfer.setData("text", ev.target.dataset.blockIndex);
        ev.target.classList.add('dragging');
    }

    function drop(ev) {
        ev.preventDefault();
        const blockIndex = ev.dataTransfer.getData("text");
        const draggedBlock = document.querySelector(`[data-block-index="${blockIndex}"]`);
        
        if (draggedBlock?.classList.contains('draggable')) {
            const targetStackIndex = parseInt(ev.currentTarget.dataset.stack);
            const sourceStackIndex = currentState.findIndex(stack => 
                stack[stack.length - 1] === parseInt(blockIndex)
            );
            
            if (sourceStackIndex !== targetStackIndex) {
                // Move in state array
                const block = currentState[sourceStackIndex].pop();
                currentState[targetStackIndex].push(block);
                
                moveCount++;
                document.getElementById('moveCountDisplay').textContent = moveCount;
                
                // Re-render and check win
                renderGame();
                checkWin();
            }
        }
    }

    document.addEventListener('dragend', () => {
        document.querySelectorAll('.block').forEach(block => {
            block.classList.remove('dragging');
        });
    });

    document.getElementById('blockCount').addEventListener('input', setupGame);
    setupGame();
</script>
<p>So, what's the strategy? Well, a fairly obvious way to do it is to just alternate which stack you take a block from, placing them in stack 3. Once all the blocks are there, you can move them to stack 1.... except, that results in the order being reversed. Actually, though this method looks promising, you need to move the blocks to stack 2 first, then to stack 1, as moving the stack one block at a time reverses the order. But we can do better than that. Imagine if we could place the blocks straight onto stack 1 in order instead of stack 3 - then we wouldn't need to waste so many moves reversing the order. Well, we can - place all of stack 1 onto stack 2 one block at a time, then pull all the blocks from stack 1 you just put on stack 2, and place them on stack 3 one at a time. You might notice that we've basically moved stack 1 to stack 3, but kept the order correct, so now we can alternate between stacks 2 and 3 to place them straight into their final places.</p>
<p>So, what's the strategy? Well, how about we ask o3-mini? I asked it to solve the problem for 52 blocks, and it actually got it correct on the first try! This was rather lucky, as from further testing, it only rarely seems to get it right. It also gave this nice explanation within its thinking block.</p>
<picture><source type="image/webp" srcset="/blog/posts/illusion-of-research/ZiDmksfCoX-748.webp 748w"><img src="/blog/posts/illusion-of-research/ZiDmksfCoX-748.jpeg" alt="Thinking trace for blocks world solution" width="748" height="210"></picture>
<p>If that wasn't clear, we can alternate between pulling a block from stack 1 and stack 2, moving the blocks onto stack 3. Once this is done, we move all of stack 3 to stack 2, which reverses it, then move all of stack 2 to stack 1, reversing it again and giving us our final result.</p>
<p>As with Tower of Hanoi, carrying out the algorithm step-by-step didn't really require any planning. However, this isn't a well-known algorithm, as it isn't common to set up the initial and target states in this way, so based off just the general rules for the Blocks World puzzle, and the initial and target states, the LLMs are able to figure out not only that the two input stacks have to be interleaved, but they also manage to turn that into an algorithm that they can apply to solve the problem.</p>
<p>This arguably demonstrates quite a reasonable capacity for problem solving - the LLMs had to consider the structure of the initial and target states, notice that there was a pattern, then figure out how to properly interleave the blocks, and finally realise that moving the blocks directly back to the first stack would reverse them, so they need to be moved twice so that they end up in the correct order. That is - the papers own data appears to contradict the authors' own conclusions.</p>
<h2>Acknowledgements</h2>
<p>Thanks to InfuriatinglyOpaque in DGG chat for discussion around this paper, as well as helping pull together various sources and articles.</p>
<p>For anyone with more of a background on testing reasoning, yes, Towers of Hanoi is often used to test and/or demonstrate reasoning of models, but this is almost exclusively in situations where the model being tested is not capable of utilising the algorithm, or in some cases, a model may be capable of using the algorithm, but Towers of Hanoi is just one of many (as in, often 1 of 50) problems tested, with the results from it being largely inconsequential to the conclusions of the paper.</p>
<p>If it's unclear why Towers of Hanoi is a different class of problem to the others, consider the steps required as a function of the solution length. Towers of Hanoi's algorithm is <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container> with <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></mjx-assistive-mml></mjx-container> as solution length. Blocks World is <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.614ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2481.3 1000" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><use data-c="1D450" xlink:href="#MJX-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(466,363) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-TEX-I-1D45B"></use></g></g><g data-mml-node="mo" transform="translate(2092.3,0)"><use data-c="29" xlink:href="#MJX-TEX-N-29"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>O</mi><mo stretchy="false">(</mo><msup><mi>c</mi><mi>n</mi></msup><mo stretchy="false">)</mo></math></mjx-assistive-mml></mjx-container>, where <mjx-container class="MathJax" jax="SVG" style="position: relative;"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.98ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 433 453" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D450" xlink:href="#MJX-TEX-I-1D450"></use></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi></math></mjx-assistive-mml></mjx-container> is some branching factor.</p>

</article>
      </div>
    </main>

    <footer></footer>

    <!-- Current page: /blog/posts/illusion-of-research/ -->
  <svg style="display: none;" id="MJX-SVG-global-cache"><defs><path id="MJX-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-TEX-N-74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z"></path><path id="MJX-TEX-N-6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z"></path><path id="MJX-TEX-N-6B" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T97 124T98 167T98 217T98 272T98 329Q98 366 98 407T98 482T98 542T97 586T97 603Q94 622 83 628T38 637H20V660Q20 683 22 683L32 684Q42 685 61 686T98 688Q115 689 135 690T165 693T176 694H179V463L180 233L240 287Q300 341 304 347Q310 356 310 364Q310 383 289 385H284V431H293Q308 428 412 428Q475 428 484 431H489V385H476Q407 380 360 341Q286 278 286 274Q286 273 349 181T420 79Q434 60 451 53T500 46H511V0H505Q496 3 418 3Q322 3 307 0H299V46H306Q330 48 330 65Q330 72 326 79Q323 84 276 153T228 222L176 176V120V84Q176 65 178 59T189 49Q210 46 238 46H254V0H246Q231 3 137 3T28 0H20V46H36Z"></path><path id="MJX-TEX-N-65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z"></path><path id="MJX-TEX-N-6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path id="MJX-TEX-N-73" d="M295 316Q295 356 268 385T190 414Q154 414 128 401Q98 382 98 349Q97 344 98 336T114 312T157 287Q175 282 201 278T245 269T277 256Q294 248 310 236T342 195T359 133Q359 71 321 31T198 -10H190Q138 -10 94 26L86 19L77 10Q71 4 65 -1L54 -11H46H42Q39 -11 33 -5V74V132Q33 153 35 157T45 162H54Q66 162 70 158T75 146T82 119T101 77Q136 26 198 26Q295 26 295 104Q295 133 277 151Q257 175 194 187T111 210Q75 227 54 256T33 318Q33 357 50 384T93 424T143 442T187 447H198Q238 447 268 432L283 424L292 431Q302 440 314 448H322H326Q329 448 335 442V310L329 304H301Q295 310 295 316Z"></path><path id="MJX-TEX-N-36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path><path id="MJX-TEX-N-D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path><path id="MJX-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-TEX-I-1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path><path id="MJX-TEX-N-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path><path id="MJX-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-TEX-N-2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path><path id="MJX-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-TEX-N-35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path><path id="MJX-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></defs></svg></body>
</html>
